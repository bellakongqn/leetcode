/**
 * 999. 车的可用捕获量
 * 在一个 8 x 8 的棋盘上，有一个白色车（rook）。
 * 也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。
 * 它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。
 * 车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），
 * 然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。
返回车能够在一次移动中捕获到的卒的数量。
输入：
[[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".","R",".",".",".","p"],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".","p",".",".",".","."],
[".",".",".",".",".",".",".","."],
[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。
下一步 车 能吃的 卒 有多少个
车是纵来横去的,能吃的只能在车的 x y 轴两个方向
所以,
只需 拿到两个数组: 横的数组 和 竖的数组
去除无关的小点
判断车的上一个或者下一个是不是 p,是就加 1
//如: 
board = [
          [".",".",".",".",".",".",".","."],
          [".",".",".","p",".",".",".","."],
          [".",".",".","p",".",".",".","."],
          ["p","p",".","R",".","p","B","."],
          [".",".",".",".",".",".",".","."],
          [".",".",".","B",".",".",".","."],
          [".",".",".","p",".",".",".","."],
          [".",".",".",".",".",".",".","."]
        ]
// 筛选之后: xlist = ["p", "p", "R", "p", "B"]  ylist = ["p", "p", "R", "B", "p"]
// 这样是不是看起来是不是简单多了, 继续!
// 我们只要看 R 的前一项和后一项: xlist = ["p", "R", "p"],  ylist=["p", "R", "B"]
 */
/**
 * @param {character[][]} board
 * @return {number}
 */
var numRookCaptures = function(board) {
    let y, xlist = [], ylist = []
    board.forEach((item,index) => {
      if(item.indexOf('R') > -1) {
        y = item.indexOf('R')
        xlist = item.filter(t => t !== '.')
      }
    })

    board.forEach(item =>{
      item[y] !=='.' && ylist.push(item[y])
    })
    
    let Rx = xlist.indexOf('R'), Ry = ylist.indexOf('R'), num = 0

    if(xlist[Rx+1] && xlist[Rx+1] === 'p') ++num
    if(xlist[Rx-1] && xlist[Rx-1] === 'p') ++num
    if(ylist[Ry+1] && ylist[Ry+1] === 'p') ++num
    if(ylist[Ry-1] && ylist[Ry-1] === 'p') ++num

    return num

};